#!/usr/bin/env python3
#
# Copyright (c) 2014 Sebastian Noack
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

import os
import sys
import argparse
import json
import pickle
import random
import string
import collections
import socket
import select
import errno
import signal
import struct
from getpass import getpass, getuser
from time import time

import Crypto.Cipher.AES
import Crypto.Hash.HMAC
import Crypto.Hash.SHA256
import Crypto.Protocol.KDF

PROGNAME = os.path.basename(__file__)
DATABASE = os.path.expanduser(os.path.join('~', '.config', PROGNAME))
SOCKET = '/tmp/%s-%s.sock' % (PROGNAME, getuser())
TIMEOUT = 60 * 30


class Error(Exception):
	pass


## Encrypted storage

KEY_SIZE = 32
SALT_SIZE = 48
ITERATIONS = 10000

class WrongPassphraseOrBrokenDatabase(Error):
	def __str__(self):
		return 'Wrong passphrase or broken database'

class Database(collections.MutableMapping):
	_header_struct = struct.Struct('{}s{}s'.format(SALT_SIZE, Crypto.Cipher.AES.block_size))

	def __init__(self):
		self._data = {}

	def __getitem__(self, nickname):
		return self._data[nickname.lower()][1]

	def __setitem__(self, nickname, password):
		self._set_item(nickname, password)
		self._write()

	def __delitem__(self, nickname):
		del self._data[nickname.lower()]
		self._write()

	def __iter__(self):
		for _, (nickname, _) in sorted(self._data.items(), key=lambda pair: pair[0]):
			yield nickname

	def __len__(self):
		return len(self._data)

	def _set_item(self, nickname, password):
		self._data[nickname.lower()] = (nickname, password)

	def _init_key(self, passphrase, salt):
		self._key = Crypto.Protocol.KDF.PBKDF2(
			passphrase.encode('utf-8'), salt, KEY_SIZE, ITERATIONS,
			lambda p, s: Crypto.Hash.HMAC.new(p, s, Crypto.Hash.SHA256).digest()
		)
		self._salt = salt
	
	def _get_cipher(self, iv):
		return Crypto.Cipher.AES.new(self._key, Crypto.Cipher.AES.MODE_CBC, iv)

	def _write(self):
		block_size = Crypto.Cipher.AES.block_size

		plaintext = json.dumps(dict(self), ensure_ascii=False).encode('utf-8')
		plaintext += b' ' * (block_size - len(plaintext) % block_size)

		iv = os.urandom(block_size)
		ciphertext = self._get_cipher(iv).encrypt(plaintext)

		with open(DATABASE, 'wb') as file:
			file.write(self._salt)
			file.write(iv)
			file.write(ciphertext)
	
	def change_passphrase(self, passphrase):
		self._init_key(passphrase, os.urandom(SALT_SIZE))
		self._write()
		
	@classmethod
	def decrypt(cls, data, passphrase):
		try:
			salt, iv = cls._header_struct.unpack_from(data)
		except struct.error:
			raise WrongPassphraseOrBrokenDatabase

		db = cls()
		db._init_key(passphrase, salt)

		cipher = db._get_cipher(iv)
		ciphertext = data[cls._header_struct.size:]

		try:
			passwords = json.loads(cipher.decrypt(ciphertext).decode('utf-8'))
		except ValueError:
			raise WrongPassphraseOrBrokenDatabase

		if not isinstance(passwords, dict):
			raise WrongPassphraseOrBrokenDatabase

		for nickname, password in passwords.items():
			db._set_item(nickname, password)

		return db

	@classmethod
	def create(cls, passphrase):
		db = cls()
		db.change_passphrase(passphrase)
		return db


## Daemon

class CommandError(Error):
	pass

class UnknownNickname(CommandError):
	def __str__(self):
		return 'Unkown nickname'

class NicknameAlreadyExists(CommandError):
	def __str__(self):
		return 'Nickname already exists'

class Daemon:
	def __init__(self, db):
		self._db = db
		self._shutdown = False
		self._connections = []

	def _handle_get(self, nickname):
		try:
			return self._db[nickname]
		except KeyError:
			raise UnknownNickname
	
	def _handle_add(self, nickname, password, override=False):
		if not override and nickname in self._db:
			raise NicknameAlreadyExists

		self._db[nickname] = password
	
	def _handle_remove(self, nickname):
		try:
			del self._db[nickname]
		except KeyError:
			raise UnknownNickname
	
	def _handle_list(self):
		return list(self._db)
	
	def _handle_changepw(self, passphrase):
		self._db.change_passphrase(passphrase)

	def _handle_shutdown(self):
		self._shutdown = True

	def _serve_request(self, conn):
		with conn.makefile('rwb', 0) as file:
			try:
				cmd, args = pickle.load(file)
			except EOFError:
				conn.close()
				self._connections.remove(conn)
				return

			try:
				response = getattr(self, '_handle_' + cmd)(*args)
			except CommandError as e:
				response = e

			pickle.dump(response, file)

	def _create_socket(self):
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
		try:
			try:
				sock.bind(SOCKET)
			except OSError as e:
				if e.errno != errno.EADDRINUSE:
					raise

				os.unlink(SOCKET)
				sock.bind(SOCKET)

			sock.listen(5)
			return sock
		except:
			self._destroy_socket(sock)
			raise

	def _destroy_socket(self, sock):
		sock.close()

		try:
			os.unlink(SOCKET)
		except FileNotFoundError:
			pass

	def run(self):
		server_socket = self._create_socket()
		try:
			while True:
				sockets = [server_socket] + self._connections
				timeout = None if self._connections else TIMEOUT
				sockets = select.select(sockets, [], [], timeout)[0]

				for sock in sockets:
					if sock is server_socket:
						conn, _ = server_socket.accept()
						self._connections.append(conn)
					else:
						self._serve_request(sock)

				if not sockets or self._shutdown:
					break
		finally:
			for conn in self._connections:
				conn.close()

			self._destroy_socket(server_socket)


## Client API

class ConnectionLost(Error):
	def __str__(self):
		return 'Connection lost'

class Client:
	DATABASE_DOES_NOT_EXIST = 1
	DATABASE_LOCKED = 2
	CONNECTED = 3

	def __init__(self):
		self._sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

		try:
			self._sock.connect(SOCKET)
		except (FileNotFoundError, ConnectionRefusedError):
			try:
				with open(DATABASE, 'rb') as file:
					self._ciphertext = file.read()
			except FileNotFoundError:
				self.status = self.DATABASE_DOES_NOT_EXIST
			else:
				self.status = self.DATABASE_LOCKED
		else:
			self.status = self.CONNECTED

	def __enter__(self):
		return self
	
	def __exit__(self, exc_type, exc_value, traceback):
		self.close()
	
	def _wait_for_connection(self):
		t = time()
		while True:
			try:
				self._sock.connect(SOCKET)
				break
			except (FileNotFoundError, ConnectionRefusedError):
				if time() - t > 1:
					raise
	
	def _spawn_daemon(self, db):
		if not os.fork():
			self.close()

			signal.signal(signal.SIGINT, signal.SIG_IGN)
			signal.signal(signal.SIGHUP, signal.SIG_IGN)

			Daemon(db).run()
			sys.exit(0)
		
		self._wait_for_connection()
		self.status = self.CONNECTED

	def create_database(self, passphrase):
		self._spawn_daemon(Database.create(passphrase))

	def unlock_database(self, passphrase):
		db = Database.decrypt(self._ciphertext, passphrase)
		del self._ciphertext
		self._spawn_daemon(db)

	def call(self, command, *args):
		with self._sock.makefile('rwb', 0) as file:
			try:
				pickle.dump((command, args), file)
				output = pickle.load(file)
			except (BrokenPipeError, EOFError):
				raise ConnectionLost

		if isinstance(output, CommandError):
			raise output

		return output

	def close(self):
		self._sock.close()


## Command line interface

def generate_password():
	chars = [
		random.choice(string.ascii_lowercase),
		random.choice(string.ascii_uppercase),
		random.choice(string.digits),
		random.choice(string.punctuation),
	]

	while len(chars) < 16:
		chars.append(chr(random.randint(33, 126)))

	random.shuffle(chars)
	return ''.join(chars)

def prompt_new_passphrase():
	password = getpass('New passphrase: ')

	if password != getpass('Verify passphrase: '):
		print("Password doesn't match!", file=sys.stderr)
		sys.exit(1)
	
	return password

class CLI:
	def __init__(self):
		try:
			self._parse_arguments()
			os.umask(0o077)

			with Client() as self._client:
				self._open_database()
				getattr(self, '_call_' + self._args.command)()
		except Error as e:
			print(e, file=sys.stderr)
			sys.exit(1)
		except KeyboardInterrupt:
			print(file=sys.stderr)
			sys.exit(1)

	def _parse_arguments(self):
		parser = argparse.ArgumentParser()

		subparsers = parser.add_subparsers(dest='command')
		subparsers.required = True

		subparser_get = subparsers.add_parser('get', help='Writes the requested password to stdout')
		subparser_get.add_argument('nickname')
		subparser_get.set_defaults(exit_if_db_does_not_exist=True)

		subparser_add = subparsers.add_parser('add', help='Adds the given password to the database')
		subparser_add.add_argument('nickname')
		subparser_add.add_argument('password', nargs='?')

		subparser_new = subparsers.add_parser('new', help='Generates a new password and adds it to the database')
		subparser_new.add_argument('nickname')

		subparser_remove = subparsers.add_parser('remove', help='Removes a password from the database')
		subparser_remove.add_argument('nickname')
		subparser_remove.set_defaults(fail_if_db_does_not_exist=True)

		subparser_list = subparsers.add_parser('list', help='Writes the nicknames of all passwords to stdout')
		subparser_list.set_defaults(exit_if_db_does_not_exist=True)

		subparser_changepw = subparsers.add_parser('changepw', help='Changes the master passphrase')
		subparser_changepw.set_defaults(fail_if_db_does_not_exist=True)

		subparser_lock = subparsers.add_parser('lock', help='Closes the database and forgets the master passhrase')
		subparser_lock.set_defaults(exit_if_disconnected=True)

		self._args = parser.parse_args()

	def _open_database(self):
		if self._client.status != Client.CONNECTED and getattr(self._args, 'exit_if_disconnected', False):
			sys.exit(0)

		if self._client.status == Client.DATABASE_DOES_NOT_EXIST:
			if getattr(self._args, 'fail_if_db_does_not_exist', False):
				print('Database does not exist', file=sys.stderr)
				sys.exit(1)

			if getattr(self._args, 'exit_if_db_does_not_exist', False):
				sys.exit(0)

			self._client.create_database(prompt_new_passphrase())

		if self._client.status == Client.DATABASE_LOCKED:
			self._client.unlock_database(getpass('Unlock database: '))

	def _call_get(self):
		print(self._client.call('get', self._args.nickname))

	def _call_add(self, password=None):
		nickname = self._args.nickname
		password = password or self._args.password or getpass()

		try:
			self._client.call('add', nickname, password)
		except NicknameAlreadyExists:
			if input('Nickname already exists. Do you want to override it? [y/N] ')[:1].lower() != 'y':
				print('Aborted', file=sys.stderr)
				sys.exit(1)

			self._client.call('add', nickname, password, True)

	def _call_new(self):
		password = generate_password()
		self._call_add(password)
		print(password)
	
	def _call_remove(self):
		self._client.call('remove', self._args.nickname)
	
	def _call_list(self):
		for nickname in self._client.call('list'):
			print(nickname)
	
	def _call_changepw(self):
		self._client.call('changepw', prompt_new_passphrase())

	def _call_lock(self):
		self._client.call('shutdown')

if __name__ == '__main__':
	CLI()
